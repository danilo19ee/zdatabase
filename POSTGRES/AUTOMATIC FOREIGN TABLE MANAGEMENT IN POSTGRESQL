++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+   AUTOMATIC FOREIGN TABLE MANAGEMENT IN POSTGRESQL   +
++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#NOTE
Foreign tables are external tables that usually have orgies in other instances of databases, 
that have a different maintenance team and that often do not establish direct communication. 
When the original table is modified, the foreign table may become unusable. 
Needing to be recreated or modified to correct its characteristics. 
The idea of the solution is to automate the process of updating foreign tables in postgres.

#CREATE TABLE REGISTER FOREING TABLES

DROP TABLE public.fdw_tables_list;
CREATE TABLE public.fdw_tables_list (
	table_schema varchar NOT NULL,
	table_name varchar NOT NULL,
	table_type varchar NULL DEFAULT 'BASE TABLE'::character varying,
	table_catalog varchar NOT NULL,
	foreign_server_name varchar NOT NULL,
	usename varchar NOT NULL,
	CONSTRAINT fdw_tables_list_pku UNIQUE (table_schema, table_name, table_type, table_catalog, foreign_server_name));

#INSERT EXISTENT FOREIGN TABLES

INSERT INTO public.fdw_tables_list(table_schema, table_name, table_catalog, foreign_server_name, usename)
select t.foreign_table_schema, t.foreign_table_name, t.foreign_table_catalog, s.foreign_server_name, u.usename
FROM information_schema.foreign_tables t join information_schema.foreign_servers s on t.foreign_server_catalog = s.foreign_server_catalog
join pg_class c on t.foreign_table_name = c.relname
join pg_user u on c.relowner = u.usesysid
where t.foreign_table_schema not in ('information_schema', 'pg_catalog', 'public');

#GENERATE FOREIGN TABLE METADATA POSTGRES

SELECT                                          
  'CREATE FOREIGN TABLE ' || table_schema || '.' || relname || E'\n(\n' ||
  array_to_string(
    array_agg(
      '    ' || column_name || ' ' ||  type || ' '|| not_null
    )
    , E',\n'
  ) || E'\n)\n SERVER ' || foreign_server_name  || E'\n OPTIONS (schema_name ''' || table_schema || ''', table_name ''' || relname || ''');' || E'\n ALTER TABLE ' || table_schema || '.' || relname || ' OWNER TO ' || usename || ';' || E'\n GRANT SELECT ON TABLE ' || table_schema || '.' || relname || ' TO ' || usename || ';'
from
(
  SELECT 
    c.relname, a.attname AS column_name,
    pg_catalog.format_type(a.atttypid, a.atttypmod) as type,
    case 
      when a.attnotnull
    then 'NOT NULL' 
    else 'NULL' 
    END as not_null, s.foreign_server_name, ts.table_schema, u.usename 
  FROM pg_attribute a,
   pg_type t,
   information_schema.tables ts
   join information_schema.foreign_servers s on ts.table_catalog = s.foreign_server_catalog
   join pg_class c on ts.table_name = c.relname
   join pg_user u on c.relowner = u.usesysid
   where ts.table_schema not in ('information_schema', 'pg_catalog') and ts.table_type = 'FOREIGN'
   AND a.attnum > 0
   AND a.attrelid = c.oid
   AND a.atttypid = t.oid
 ORDER BY a.attnum
) as tabledefinition
group by relname, foreign_server_name, table_schema, usename;

#CREATE FOREIGN TABLES FOR MANAGE METADATA
CREATE FOREIGN TABLE public.pg_attribute_f (
 attrelid oid not null, 
 attname name not null, 
 atttypid oid not null, 
 attstattarget integer not null, 
 attlen smallint not null, 
 attnum smallint not null, 
 attndims integer not null, 
 attcacheoff integer not null, 
 atttypmod integer not null, 
 attbyval boolean not null, 
 attstorage "char" not null, 
 attalign "char" not null, 
 attnotnull boolean not null, 
 atthasdef boolean not null, 
 atthasmissing boolean not null, 
 attidentity "char"  not null, 
 attisdropped boolean not null, 
 attislocal boolean not null, 
 attinhcount integer not null, 
 attcollation oid not null, 
 attacl aclitem[],
 attoptions text[], 
 attfdwoptions text[], 
 attmissingval varchar(100))
SERVER fdw_pg11
OPTIONS (schema_name 'pg_catalog', table_name 'pg_attribute');

ALTER TABLE public.pg_attribute_f OWNER TO postgres;
GRANT SELECT ON TABLE public.pg_attribute_f TO postgres;

CREATE FOREIGN TABLE public.pg_type_f (
	oid oid,
	typname char[] NOT NULL,
	typnamespace oid NOT NULL,
	typowner oid NOT NULL,
	typlen int2 NOT NULL,
	typbyval bool NOT NULL,
	typtype char(1) NOT NULL,
	typcategory char(1) NOT NULL,
	typispreferred bool NOT NULL,
	typisdefined bool NOT NULL,
	typdelim char(1) NOT NULL,
	typrelid oid NOT NULL,
	typelem oid NOT NULL,
	typarray oid NOT NULL,
	typinput regproc NOT NULL,
	typoutput regproc NOT NULL,
	typreceive regproc NOT NULL,
	typsend regproc NOT NULL,
	typmodin regproc NOT NULL,
	typmodout regproc NOT NULL,
	typanalyze regproc NOT NULL,
	typalign char(1) NOT NULL,
	typstorage char(1) NOT NULL,
	typnotnull bool NOT NULL,
	typbasetype oid NOT NULL,
	typtypmod int4 NOT NULL,
	typndims int4 NOT NULL,
	typcollation oid NOT NULL,
	typdefaultbin pg_node_tree NULL,
	typdefault text NULL,
	typacl varchar(100) NULL)
SERVER fdw_pg11
OPTIONS (schema_name 'pg_catalog', table_name 'pg_type');

ALTER TABLE public.pg_type_f OWNER TO postgres;
GRANT ALL ON TABLE public.pg_type_f TO postgres;

CREATE FOREIGN TABLE public.pg_namespace_f (
	oid oid NOT null,
	nspname varchar(100) NOT NULL,
	nspowner oid NOT NULL,
	nspacl varchar(100) NULL)
SERVER fdw_pg11
OPTIONS (schema_name 'pg_catalog', table_name 'pg_namespace');

ALTER TABLE public.pg_namespace_f OWNER TO postgres;
GRANT ALL ON TABLE public.pg_namespace_f TO postgres;

CREATE FOREIGN TABLE public.pg_class_f (
	"oid" oid NOT NULL,
	relname varchar(100) NOT NULL,
	relnamespace oid NOT NULL,
	reltype oid NOT NULL,
	reloftype oid NOT NULL,
	relowner oid NOT NULL,
	relam oid NOT NULL,
	relfilenode oid NOT NULL,
	reltablespace oid NOT NULL,
	relpages int4 NOT NULL,
	reltuples float4 NOT NULL,
	relallvisible int4 NOT NULL,
	reltoastrelid oid NOT NULL,
	relhasindex bool NOT NULL,
	relisshared bool NOT NULL,
	relpersistence bpchar(1) NOT NULL,
	relkind bpchar(1) NOT NULL,
	relnatts int2 NOT NULL,
	relchecks int2 NOT NULL,
	relhasoids bool NOT NULL,
	relhasrules bool NOT NULL,
	relhastriggers bool NOT NULL,
	relhassubclass bool NOT NULL,
	relrowsecurity bool NOT NULL,
	relforcerowsecurity bool NOT NULL,
	relispopulated bool NOT NULL,
	relreplident bpchar(1) NOT NULL,
	relispartition bool NOT NULL,
	relrewrite oid NOT NULL,
	relfrozenxid xid NOT NULL,
	relminmxid xid NOT NULL,
	relacl varchar(100) NULL,
	reloptions text[] NULL,
	relpartbound pg_node_tree NULL)
SERVER fdw_pg11
OPTIONS (schema_name 'pg_catalog', table_name 'pg_class');

ALTER TABLE public.pg_class_f OWNER TO postgres;
GRANT ALL ON TABLE public.pg_class_f TO postgres;

CREATE FOREIGN TABLE public.pg_user_f (
	usename name, 
	usesysid oid,  
	usecreatedb boolean, 
	usesuper boolean, 
	userepl boolean, 
	usebypassrls boolean, 
	passwd text, 
	valuntil abstime, 
	useconfig text[]) 
SERVER fdw_pg11
OPTIONS (schema_name 'pg_catalog', table_name 'pg_user');

ALTER TABLE public.pg_user_f OWNER TO postgres;
GRANT ALL ON TABLE public.pg_user_f TO postgres;

#CREATE VIEW FOR LIST REMOTE SCHEMAS AND TABLES
create view public.information_schema_tables_v as 
 SELECT nc.nspname::information_schema.sql_identifier AS table_schema,
    c.relname::information_schema.sql_identifier AS table_name,
            CASE
            WHEN nc.oid = pg_my_temp_schema() THEN 'LOCAL TEMPORARY'::text
            WHEN c.relkind = ANY (ARRAY['r'::"char", 'p'::"char"]) THEN 'BASE TABLE'::text
            WHEN c.relkind = 'v'::"char" THEN 'VIEW'::text
            WHEN c.relkind = 'f'::"char" THEN 'FOREIGN'::text
            ELSE NULL::text
        END::information_schema.character_data AS table_type
   FROM pg_namespace_f nc
     JOIN pg_class_f c ON nc.oid = c.relnamespace
     LEFT JOIN (pg_type_f t
     JOIN pg_namespace_f nt ON t.typnamespace = nt.oid) ON c.reloftype = t.oid
  WHERE (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])) 
  AND NOT pg_is_other_temp_schema(nc.oid) 
  AND (pg_has_role(c.relowner, 'USAGE'::text) 
  OR has_table_privilege(c.oid, 'SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) 
  OR has_any_column_privilege(c.oid, 'SELECT, INSERT, UPDATE, REFERENCES'::text));
  
  



